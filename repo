#!/usr/bin/env python
# -*- coding: utf-8 -*-

# repo default configuration
#
"""
通过 REPO_URL/REPO_REV 指定clone的地址和分支
1. 尝试获取环境变量'REPO_URL'的值，如果没有设置，则使用google官方地址
2. 默认下载stable分支
"""
import os
REPO_URL = os.environ.get('REPO_URL', None)
if not REPO_URL:
  REPO_URL = 'https://gerrit.googlesource.com/git-repo'
REPO_REV = 'stable'

# Copyright (C) 2008 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# increment this whenever we make important changes to this script
VERSION = (1, 23)

# increment this if the MAINTAINER_KEYS block is modified
KEYRING_VERSION = (1, 2)

# Each individual key entry is created by using:
# gpg --armor --export keyid
MAINTAINER_KEYS = """

     Repo Maintainer <repo@android.kernel.org>
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: GnuPG v1.4.2.2 (GNU/Linux)

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
=CMiZ
-----END PGP PUBLIC KEY BLOCK-----

     Conley Owens <cco3@android.com>
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: GnuPG v1.4.11 (GNU/Linux)

mQENBFHRvc8BCADFg45Xx/y6QDC+T7Y/gGc7vx0ww7qfOwIKlAZ9xG3qKunMxo+S
hPCnzEl3cq+6I1Ww/ndop/HB3N3toPXRCoN8Vs4/Hc7by+SnaLFnacrm+tV5/OgT
V37Lzt8lhay1Kl+YfpFwHYYpIEBLFV9knyfRXS/428W2qhdzYfvB15/AasRmwmor
py4NIzSs8UD/SPr1ihqNCdZM76+MQyN5HMYXW/ALZXUFG0pwluHFA7hrfPG74i8C
zMiP7qvMWIl/r/jtzHioH1dRKgbod+LZsrDJ8mBaqsZaDmNJMhss9g76XvfMyLra
9DI9/iFuBpGzeqBv0hwOGQspLRrEoyTeR6n1ABEBAAG0H0NvbmxleSBPd2VucyA8
Y2NvM0BhbmRyb2lkLmNvbT6JATgEEwECACIFAlHRvc8CGwMGCwkIBwMCBhUIAgkK
CwQWAgMBAh4BAheAAAoJEGe35EhpKzgsP6AIAJKJmNtn4l7hkYHKHFSo3egb6RjQ
zEIP3MFTcu8HFX1kF1ZFbrp7xqurLaE53kEkKuAAvjJDAgI8mcZHP1JyplubqjQA
xvv84gK+OGP3Xk+QK1ZjUQSbjOpjEiSZpRhWcHci3dgOUH4blJfByHw25hlgHowd
a/2PrNKZVcJ92YienaxxGjcXEUcd0uYEG2+rwllQigFcnMFDhr9B71MfalRHjFKE
fmdoypqLrri61YBc59P88Rw2/WUpTQjgNubSqa3A2+CKdaRyaRw+2fdF4TdR0h8W
zbg+lbaPtJHsV+3mJC7fq26MiJDRJa5ZztpMn8su20gbLgi2ShBOaHAYDDi5AQ0E
UdG9zwEIAMoOBq+QLNozAhxOOl5GL3StTStGRgPRXINfmViTsihrqGCWBBUfXlUE
OytC0mYcrDUQev/8ToVoyqw+iGSwDkcSXkrEUCKFtHV/GECWtk1keyHgR10YKI1R
mquSXoubWGqPeG1PAI74XWaRx8UrL8uCXUtmD8Q5J7mDjKR5NpxaXrwlA0bKsf2E
Gp9tu1kKauuToZhWHMRMqYSOGikQJwWSFYKT1KdNcOXLQF6+bfoJ6sjVYdwfmNQL
Ixn8QVhoTDedcqClSWB17VDEFDFa7MmqXZz2qtM3X1R/MUMHqPtegQzBGNhRdnI2
V45+1Nnx/uuCxDbeI4RbHzujnxDiq70AEQEAAYkBHwQYAQIACQUCUdG9zwIbDAAK
CRBnt+RIaSs4LNVeB/0Y2pZ8I7gAAcEM0Xw8drr4omg2fUoK1J33ozlA/RxeA/lJ
I3KnyCDTpXuIeBKPGkdL8uMATC9Z8DnBBajRlftNDVZS3Hz4G09G9QpMojvJkFJV
By+01Flw/X+eeN8NpqSuLV4W+AjEO8at/VvgKr1AFvBRdZ7GkpI1o6DgPe7ZqX+1
dzQZt3e13W0rVBb/bUgx9iSLoeWP3aq/k+/GRGOR+S6F6BBSl0SQ2EF2+dIywb1x
JuinEP+AwLAUZ1Bsx9ISC0Agpk2VeHXPL3FGhroEmoMvBzO0kTFGyoeT7PR/BfKv
+H/g3HsL2LOB9uoIm8/5p2TTU5ttYCXMHhQZ81AY
=AUp4
-----END PGP PUBLIC KEY BLOCK-----
"""

GIT = 'git'                      # our git command
MIN_GIT_VERSION = (1, 7, 2)      # minimum supported git version
repodir = '.repo'                # name of repo's private directory
S_repo = 'repo'                  # special repo repository
S_manifests = 'manifests'        # special manifest repository
REPO_MAIN = S_repo + '/main.py'  # main script
MIN_PYTHON_VERSION = (2, 6)      # minimum supported python version
GITC_CONFIG_FILE = '/gitc/.config'
GITC_FS_ROOT_DIR = '/gitc/manifest-rw/'


import errno
import optparse
import re
import shutil
import stat
import subprocess
import sys

"""
urllib的兼容性处理

检查python解释器版本，根据不同版本对urllib进行不同的处理，为不同版本解释器访问urllib库使用统一的接口。

Python3中，urllib包含多个子模块：
- urllib.request
- urllib.error
- urllib.parse
- urllib.robotparser

Python2中，分为urllib和urllib2，其功能不同。

使用imp.new_module('urllib')生成一个名为'urllib'空白库，然后将urllib2作为其request和error成员的实现。
因此这里生成的urllib同python2自带的urllib库是不一样的，只是名字相同而已。
也可以理解为使用Python2现有库构造一个Python3使用方式一样的urllib库。
"""
if sys.version_info[0] == 3:
  import urllib.request
  import urllib.error
else:
  import imp
  import urllib2
  urllib = imp.new_module('urllib')
  urllib.request = urllib2
  urllib.error = urllib2


def _print(*objects, **kwargs):
  sep = kwargs.get('sep', ' ')
  end = kwargs.get('end', '\n')
  out = kwargs.get('file', sys.stdout)
  out.write(sep.join(objects) + end)


# Python version check
ver = sys.version_info
if (ver[0], ver[1]) < MIN_PYTHON_VERSION:
  _print('error: Python version %s unsupported.\n'
         'Please use Python 2.6 - 2.7 instead.'
         % sys.version.split(' ')[0], file=sys.stderr)
  sys.exit(1)

home_dot_repo = os.path.expanduser('~/.repoconfig')
gpg_dir = os.path.join(home_dot_repo, 'gnupg')

extra_args = []

"""
构建'repo init'命令的选项, 包括Logging, Manifest, Tool和Other四个部分。

git-repo$ repo help init
Usage: repo init -u url [options]

Options:
  -h, --help            show this help message and exit

  Logging options:
    -q, --quiet         be quiet

  Manifest options:
    -u URL, --manifest-url=URL
                        manifest repository location
    -b REVISION, --manifest-branch=REVISION
                        manifest branch or revision
    -m NAME.xml, --manifest-name=NAME.xml
                        initial manifest file
    --mirror            create a replica of the remote repositories rather
                        than a client working directory
    --reference=DIR     location of mirror directory
    --depth=DEPTH       create a shallow clone with given depth; see git clone
    --archive           checkout an archive instead of a git repository for
                        each project. See git archive.
    -g GROUP, --groups=GROUP
                        restrict manifest projects to ones with specified
                        group(s) [default|all|G1,G2,G3|G4,-G5,-G6]
    -p PLATFORM, --platform=PLATFORM
                        restrict manifest projects to ones with a specified
                        platform group [auto|all|none|linux|darwin|...]
    --no-clone-bundle   disable use of /clone.bundle on HTTP/HTTPS

  repo Version options:
    --repo-url=URL      repo repository location
    --repo-branch=REVISION
                        repo branch or revision
    --no-repo-verify    do not verify repo source code

  Other options:
    --config-name       Always prompt for name/e-mail
"""
init_optparse = optparse.OptionParser(usage="repo init -u url [options]")

# Logging
group = init_optparse.add_option_group('Logging options')
group.add_option('-q', '--quiet',
                 dest="quiet", action="store_true", default=False,
                 help="be quiet")

# Manifest
group = init_optparse.add_option_group('Manifest options')
group.add_option('-u', '--manifest-url',
                 dest='manifest_url',
                 help='manifest repository location', metavar='URL')
group.add_option('-b', '--manifest-branch',
                 dest='manifest_branch',
                 help='manifest branch or revision', metavar='REVISION')
group.add_option('-m', '--manifest-name',
                 dest='manifest_name',
                 help='initial manifest file', metavar='NAME.xml')
group.add_option('--mirror',
                 dest='mirror', action='store_true',
                 help='create a replica of the remote repositories '
                      'rather than a client working directory')
group.add_option('--reference',
                 dest='reference',
                 help='location of mirror directory', metavar='DIR')
group.add_option('--depth', type='int', default=None,
                 dest='depth',
                 help='create a shallow clone with given depth; see git clone')
group.add_option('--archive',
                 dest='archive', action='store_true',
                 help='checkout an archive instead of a git repository for '
                      'each project. See git archive.')
group.add_option('-g', '--groups',
                 dest='groups', default='default',
                 help='restrict manifest projects to ones with specified '
                      'group(s) [default|all|G1,G2,G3|G4,-G5,-G6]',
                 metavar='GROUP')
group.add_option('-p', '--platform',
                 dest='platform', default="auto",
                 help='restrict manifest projects to ones with a specified '
                      'platform group [auto|all|none|linux|darwin|...]',
                 metavar='PLATFORM')
group.add_option('--no-clone-bundle',
                 dest='no_clone_bundle', action='store_true',
                 help='disable use of /clone.bundle on HTTP/HTTPS')


# Tool
group = init_optparse.add_option_group('repo Version options')
group.add_option('--repo-url',
                 dest='repo_url',
                 help='repo repository location', metavar='URL')
group.add_option('--repo-branch',
                 dest='repo_branch',
                 help='repo branch or revision', metavar='REVISION')
group.add_option('--no-repo-verify',
                 dest='no_repo_verify', action='store_true',
                 help='do not verify repo source code')

# Other
group = init_optparse.add_option_group('Other options')
group.add_option('--config-name',
                 dest='config_name', action="store_true", default=False,
                 help='Always prompt for name/e-mail')


def _GitcInitOptions(init_optparse_arg):
  init_optparse_arg.set_usage("repo gitc-init -u url -c client [options]")
  g = init_optparse_arg.add_option_group('GITC options')
  g.add_option('-f', '--manifest-file',
               dest='manifest_file',
               help='Optional manifest file to use for this GITC client.')
  g.add_option('-c', '--gitc-client',
               dest='gitc_client',
               help='The name of the gitc_client instance to create or modify.')

_gitc_manifest_dir = None


def get_gitc_manifest_dir():
  global _gitc_manifest_dir
  if _gitc_manifest_dir is None:
    _gitc_manifest_dir = ''
    try:
      with open(GITC_CONFIG_FILE, 'r') as gitc_config:
        for line in gitc_config:
          match = re.match('gitc_dir=(?P<gitc_manifest_dir>.*)', line)
          if match:
            _gitc_manifest_dir = match.group('gitc_manifest_dir')
    except IOError:
      pass
  return _gitc_manifest_dir


def gitc_parse_clientdir(gitc_fs_path):
  """Parse a path in the GITC FS and return its client name.

  @param gitc_fs_path: A subdirectory path within the GITC_FS_ROOT_DIR.

  @returns: The GITC client name
  """
  if gitc_fs_path == GITC_FS_ROOT_DIR:
    return None
  if not gitc_fs_path.startswith(GITC_FS_ROOT_DIR):
    manifest_dir = get_gitc_manifest_dir()
    if manifest_dir == '':
      return None
    if manifest_dir[-1] != '/':
      manifest_dir += '/'
    if gitc_fs_path == manifest_dir:
      return None
    if not gitc_fs_path.startswith(manifest_dir):
      return None
    return gitc_fs_path.split(manifest_dir)[1].split('/')[0]
  return gitc_fs_path.split(GITC_FS_ROOT_DIR)[1].split('/')[0]


class CloneFailure(Exception):

  """Indicate the remote clone of repo itself failed.
  """


"""
调用: _Init(args=['-u', 'https://android.googlesource.com/platform/manifest', '-b', 'android-4.0.1_r1'],
          gitc_init=(cmd == 'gitc-init'))
"""
def _Init(args, gitc_init=False):
  """Installs repo by cloning it over the network.
  """
  if gitc_init:
    _GitcInitOptions(init_optparse)
  opt, args = init_optparse.parse_args(args)
  if args:
    init_optparse.print_usage()
    sys.exit(1)

  """
  检查命令行传递进来的repo-url和repo-branch选项：
  '--repo-url'    --> opt.repo_url
  '--repo-branch' --> opt.repo_branch
  并添加如下参数到extra_args:
  '--repo-url=https://gerrit.googlesource.com/git-repo --repo-branch=stable'

  1. 如果没有指定repo-url, 则使用系统默认的REPO_URL设置。
  2. 如果没有指定repo-branch, 则使用系统默认的REPO_REV设置

  repo_url的设置优先级如下：
    1. '--repo-url'选项
    2. 环境变量'REPO_URL'
    3. google官方地址: ''https://gerrit.googlesource.com/git-repo'

  repo_branch的设置优先级如下：
    1. '--repo-branch'选项
    2. 'stable'分支
  """
  url = opt.repo_url
  if not url:
    url = REPO_URL
    extra_args.append('--repo-url=%s' % url)

  branch = opt.repo_branch
  if not branch:
    branch = REPO_REV
    extra_args.append('--repo-branch=%s' % branch)

  """
  检查branch对应的分支参数:
  1. 如果以'refs/heads/'开始, 则取尾部的分支名称
  2. 如果以'refs/'开始，则说明是无效分支

  如果当前git-repo下有一个stable分支，则引用如下：

  git-repo$ tree .git/refs/
  .git/refs/
  |-- heads
  |   |-- master
  |   `-- stable
  |-- remotes
  |   `-- origin
  |       `-- HEAD
  `-- tags

  4 directories, 3 files

  可见这里的'stable'分支全名为'refs/heads/stable'，且没有名称以'refs/'开始的分支，如'refs/stable'。
  """
  if branch.startswith('refs/heads/'):
    branch = branch[len('refs/heads/'):]
  if branch.startswith('refs/'):
    _print("fatal: invalid branch name '%s'" % branch, file=sys.stderr)
    raise CloneFailure()

  try:
    if gitc_init:
      gitc_manifest_dir = get_gitc_manifest_dir()
      if not gitc_manifest_dir:
        _print('fatal: GITC filesystem is not available. Exiting...',
               file=sys.stderr)
        sys.exit(1)
      gitc_client = opt.gitc_client
      if not gitc_client:
        gitc_client = gitc_parse_clientdir(os.getcwd())
      if not gitc_client:
        _print('fatal: GITC client (-c) is required.', file=sys.stderr)
        sys.exit(1)
      client_dir = os.path.join(gitc_manifest_dir, gitc_client)
      if not os.path.exists(client_dir):
        os.makedirs(client_dir)
      os.chdir(client_dir)
      if os.path.exists(repodir):
        # This GITC Client has already initialized repo so continue.
        return

    os.mkdir(repodir)
  except OSError as e:
    if e.errno != errno.EEXIST:
      _print('fatal: cannot make %s directory: %s'
             % (repodir, e.strerror), file=sys.stderr)
      # Don't raise CloneFailure; that would delete the
      # name. Instead exit immediately.
      #
      sys.exit(1)

  """
  余下代码执行以下操作:
  1. 检查git版本是否大于1.7.2
  2. 设置GnuPG验证环境
  3. 调用_Clone()将url指定的远程repo库复制到本地
  4. 只用GnuPG的key对制定的branch进行校验
  5. 检出branch指定的分支，默认检出'stable'分支
  """
  _CheckGitVersion()
  try:
    if NeedSetupGnuPG():
      can_verify = SetupGnuPG(opt.quiet)
    else:
      can_verify = True

    dst = os.path.abspath(os.path.join(repodir, S_repo))
    """
    复制远程的repo库到本地，如：
    _Clone(url='https://gerrit.googlesource.com/git-repo', local='/path/to/test/.repo/repo', quiet=False, clone_bundle=True)

    将url('https://gerrit.googlesource.com/git-repo')指定的repo复制到本地'.repo/repo'目录。
    """
    _Clone(url, dst, opt.quiet, not opt.no_clone_bundle)

    if can_verify and not opt.no_repo_verify:
      rev = _Verify(dst, branch, opt.quiet)
    else:
      rev = 'refs/remotes/origin/%s^0' % branch

    """
    根据branch设置检出分支。

    branch由传入的'--repo-branch'选项设置, 没有时默认为REPO_REV='stable'，所以默认会检出repo库的'stable'分支。
    """
    _Checkout(dst, branch, rev, opt.quiet)
  except CloneFailure:
    if opt.quiet:
      _print('fatal: repo init failed; run without --quiet to see why',
             file=sys.stderr)
    raise


def ParseGitVersion(ver_str):
  if not ver_str.startswith('git version '):
    return None

  num_ver_str = ver_str[len('git version '):].strip().split('-')[0]
  to_tuple = []
  for num_str in num_ver_str.split('.')[:3]:
    if num_str.isdigit():
      to_tuple.append(int(num_str))
    else:
      to_tuple.append(0)
  return tuple(to_tuple)


def _CheckGitVersion():
  cmd = [GIT, '--version']
  try:
    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE)
  except OSError as e:
    _print(file=sys.stderr)
    _print("fatal: '%s' is not available" % GIT, file=sys.stderr)
    _print('fatal: %s' % e, file=sys.stderr)
    _print(file=sys.stderr)
    _print('Please make sure %s is installed and in your path.' % GIT,
           file=sys.stderr)
    raise CloneFailure()

  ver_str = proc.stdout.read().strip()
  proc.stdout.close()
  proc.wait()

  ver_act = ParseGitVersion(ver_str)
  if ver_act is None:
    _print('error: "%s" unsupported' % ver_str, file=sys.stderr)
    raise CloneFailure()

  if ver_act < MIN_GIT_VERSION:
    need = '.'.join(map(str, MIN_GIT_VERSION))
    _print('fatal: git %s or later required' % need, file=sys.stderr)
    raise CloneFailure()


def NeedSetupGnuPG():
  if not os.path.isdir(home_dot_repo):
    return True

  kv = os.path.join(home_dot_repo, 'keyring-version')
  if not os.path.exists(kv):
    return True

  kv = open(kv).read()
  if not kv:
    return True

  kv = tuple(map(int, kv.split('.')))
  if kv < KEYRING_VERSION:
    return True
  return False


def SetupGnuPG(quiet):
  try:
    os.mkdir(home_dot_repo)
  except OSError as e:
    if e.errno != errno.EEXIST:
      _print('fatal: cannot make %s directory: %s'
             % (home_dot_repo, e.strerror), file=sys.stderr)
      sys.exit(1)

  try:
    os.mkdir(gpg_dir, stat.S_IRWXU)
  except OSError as e:
    if e.errno != errno.EEXIST:
      _print('fatal: cannot make %s directory: %s' % (gpg_dir, e.strerror),
             file=sys.stderr)
      sys.exit(1)

  env = os.environ.copy()
  try:
    env['GNUPGHOME'] = gpg_dir
  except UnicodeEncodeError:
    env['GNUPGHOME'] = gpg_dir.encode()

  cmd = ['gpg', '--import']
  try:
    proc = subprocess.Popen(cmd,
                            env=env,
                            stdin=subprocess.PIPE)
  except OSError as e:
    if not quiet:
      _print('warning: gpg (GnuPG) is not available.', file=sys.stderr)
      _print('warning: Installing it is strongly encouraged.', file=sys.stderr)
      _print(file=sys.stderr)
    return False

  proc.stdin.write(MAINTAINER_KEYS)
  proc.stdin.close()

  if proc.wait() != 0:
    _print('fatal: registering repo maintainer keys failed', file=sys.stderr)
    sys.exit(1)
  _print()

  fd = open(os.path.join(home_dot_repo, 'keyring-version'), 'w')
  fd.write('.'.join(map(str, KEYRING_VERSION)) + '\n')
  fd.close()
  return True


def _SetConfig(local, name, value):
  """Set a git configuration option to the specified value.
  """
  cmd = [GIT, 'config', name, value]
  if subprocess.Popen(cmd, cwd=local).wait() != 0:
    raise CloneFailure()


def _InitHttp():
  handlers = []

  mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()
  try:
    import netrc
    n = netrc.netrc()
    for host in n.hosts:
      p = n.hosts[host]
      mgr.add_password(p[1], 'http://%s/' % host, p[0], p[2])
      mgr.add_password(p[1], 'https://%s/' % host, p[0], p[2])
  except:  # pylint: disable=bare-except
    pass
  handlers.append(urllib.request.HTTPBasicAuthHandler(mgr))
  handlers.append(urllib.request.HTTPDigestAuthHandler(mgr))

  if 'http_proxy' in os.environ:
    url = os.environ['http_proxy']
    handlers.append(urllib.request.ProxyHandler({'http': url, 'https': url}))
  if 'REPO_CURL_VERBOSE' in os.environ:
    handlers.append(urllib.request.HTTPHandler(debuglevel=1))
    handlers.append(urllib.request.HTTPSHandler(debuglevel=1))
  urllib.request.install_opener(urllib.request.build_opener(*handlers))


"""
构建并执行'git fetch'命令获取src指定的远程库数据到本地local目录下。

对于url指定的远程库, _Fetch(url, local, 'origin', quiet) 执行命令:
  'git fetch origin +refs/heads/*:refs/remotes/origin/* refs/tags/*:refs/tags/*'

对于clone.bundle的本地文件, _Fetch(url, local, '/path/to/git-repo/.git/clone.bundle', quiet) 执行命令:
  'git fetch /path/to/git-repo/.git/clone.bundle +refs/heads/*:refs/remotes/origin/* refs/tags/*:refs/tags/*'

- url
为什么感觉url参数很重要，却没有被使用呢？ 因为url参数已经被写在.git/config文件中了，如：
git-repo$ cat .git/config
...
[remote "origin"]
        url = https://gerrit.googlesource.com/git-repo
        fetch = +refs/heads/*:refs/remotes/origin/*
...

- local
local参数被传递给cwd变量，用于指定执行'git fetch'命令时所在的路径。

- src
src参数用于指定'git fetch'的源:
  - 如果是remote源，例如通常的'origin'，.git/config文件中对应remote有一个相应的url
  - 如果是bundle源，为bundle文件的路径
换一种说法，'git fetch'通过src参数知道从哪里拿数据。

- quiet
根据quiet的值，决定'git fetch'操作的error log送往管道还是标准的错误输出设备。
"""
def _Fetch(url, local, src, quiet):
  if not quiet:
    _print('Get %s' % url, file=sys.stderr)

  cmd = [GIT, 'fetch']
  if quiet:
    cmd.append('--quiet')
    err = subprocess.PIPE
  else:
    err = None
  cmd.append(src)
  cmd.append('+refs/heads/*:refs/remotes/origin/*')
  cmd.append('refs/tags/*:refs/tags/*')

  proc = subprocess.Popen(cmd, cwd=local, stderr=err)
  if err:
    proc.stderr.read()
    proc.stderr.close()
  if proc.wait() != 0:
    raise CloneFailure()

"""
下载url指定位置的clone.bundle数据并写入local下的.git/clone.bundle文件
"""
def _DownloadBundle(url, local, quiet):
  if not url.endswith('/'):
    url += '/'
  url += 'clone.bundle'

  """
  检查传入的url地址是否满足.git/config中url替换的规则，如果是，则使用insteadof规则进行相应处理。

  以下是具体的解释：

  执行: 'git config --get-regexp url.*.insteadof'
  找出 .git/config 文件中所有 'url.*.insteadof'的节。

  如以下操作:
  $ git config url."http://localhost".insteadOf https://gerrit.googlesource.com
  $ git config --add url."http://localhost".insteadOf http://github.com/guyongqiangx
  $ cat .git/config
  ...
  [url "http://localhost"]
          insteadOf = https://gerrit.googlesource.com
          insteadOf = http://github.com/guyongqiangx
  $ git config --get-regexp url.*.insteadof
  url.http://localhost.insteadof https://gerrit.googlesource.com
  url.http://localhost.insteadof http://github.com/guyongqiangx

  执行match操作后：
  line 1:
  new_url --> http://localhost
  old_url --> https://gerrit.googlesource.com

  line 2:
  new_url --> http://localhost
  old_url --> http://github.com/guyongqiangx

  然后对传入的url进行替换。
  假设url='https://gerrit.googlesource.com/git-repo', 替换后url='http://localhost/git-repo'

  """
  proc = subprocess.Popen(
      [GIT, 'config', '--get-regexp', 'url.*.insteadof'],
      cwd=local,
      stdout=subprocess.PIPE)
  for line in proc.stdout:
    m = re.compile(r'^url\.(.*)\.insteadof (.*)$').match(line)
    if m:
      new_url = m.group(1)
      old_url = m.group(2)
      if url.startswith(old_url):
        url = new_url + url[len(old_url):]
        break
  proc.stdout.close()
  proc.wait()

  """
  如果url不以'http:'或'https:'开头，则什么都不做，直接返回。
  例如，以'file://'开头，说明在本地，不需要用urllib.request下载。
  """
  if not url.startswith('http:') and not url.startswith('https:'):
    return False

  """
  构建本地clone.bundle文件的路径，如：/path/to/git-repo/.git/clone.bundle

  然后将远程获取的clone.bundle文件数据写到本地。
  """
  dest = open(os.path.join(local, '.git', 'clone.bundle'), 'w+b')
  try:
    try:
      r = urllib.request.urlopen(url)
    except urllib.error.HTTPError as e:
      if e.code in [401, 403, 404, 501]:
        return False
      _print('fatal: Cannot get %s' % url, file=sys.stderr)
      _print('fatal: HTTP error %s' % e.code, file=sys.stderr)
      raise CloneFailure()
    except urllib.error.URLError as e:
      _print('fatal: Cannot get %s' % url, file=sys.stderr)
      _print('fatal: error %s' % e.reason, file=sys.stderr)
      raise CloneFailure()
    try:
      if not quiet:
        _print('Get %s' % url, file=sys.stderr)
      while True:
        buf = r.read(8192)
        if buf == '':
          return True
        dest.write(buf)
    finally:
      r.close()
  finally:
    dest.close()

"""
导入本地路径下的clone.bundle文件，如：/path/to/git-repo, 完成后删除bundle文件

则此时尝试导入/path/to/git-repo/.git/clone.bundle并删除:
'git fetch /path/to/git-repo/.git/clone.bundle +refs/heads/*:refs/remotes/origin/* refs/tags/*:refs/tags/*'
"""
def _ImportBundle(local):
  path = os.path.join(local, '.git', 'clone.bundle')
  try:
    """
    假如 local = '/path/to/git-repo', 则:
    _Fetch('/path/to/git-repo', '/path/to/git-repo', '/path/to/git-repo/.git/clone.bundle', True)

    _Fetch函数中进一步调用的'git fetch'命令为:
    'git fetch /path/to/git-repo/.git/clone.bundle +refs/heads/*:refs/remotes/origin/* refs/tags/*:refs/tags/*'
    """
    _Fetch(local, local, path, True)
  finally:
    os.remove(path)

"""
复制由url指定的远程git库到本地local指定的目录下。

如果支持bundle方式，则会先下载并导入clone.bundle文件，在此基础上执行'git fetch'操作，这样可以减少网络数据传输量。
试想，一次传输一个大文件的效率和将大文件分为几百上千片再进行传输的效率，哪个高呢？

不使用bundle的情况下，直接执行'git fetch'下载远端git库。
"""
def _Clone(url, local, quiet, clone_bundle):
  """Clones a git repository to a new subdirectory of repodir
  """
  try:
    os.mkdir(local)
  except OSError as e:
    _print('fatal: cannot make %s directory: %s' % (local, e.strerror),
           file=sys.stderr)
    raise CloneFailure()

  """
  在local目录下执行: 'git init --quiet'
  """
  cmd = [GIT, 'init', '--quiet']
  try:
    proc = subprocess.Popen(cmd, cwd=local)
  except OSError as e:
    _print(file=sys.stderr)
    _print("fatal: '%s' is not available" % GIT, file=sys.stderr)
    _print('fatal: %s' % e, file=sys.stderr)
    _print(file=sys.stderr)
    _print('Please make sure %s is installed and in your path.' % GIT,
           file=sys.stderr)
    raise CloneFailure()
  if proc.wait() != 0:
    _print('fatal: could not create %s' % local, file=sys.stderr)
    raise CloneFailure()

  """
  执行以下操作:
  1. 初始化http连接, 可能还需要输入相应的用户名和密码

  2. 设置远程remote的origin源的url地址, 例如:
     在local目录下执行: 'git config remote.origin.url https://gerrit.googlesource.com/git-repo'

  3. 设置远程remote的origin源与本地分支在fetch操作时的对应关系
     在local目录下执行: 'git config remote.origin.fetch +refs/heads/*:refs/remotes/origin/*'

  操作完成后, '.git/config'中会添加如下内容:
  $ cat .git/config
  ...
  [remote "origin"]
    url = https://gerrit.googlesource.com/git-repo
    fetch = +refs/heads/*:refs/remotes/origin/*
  ...
  """
  _InitHttp()
  _SetConfig(local, 'remote.origin.url', url)
  _SetConfig(local,
             'remote.origin.fetch',
             '+refs/heads/*:refs/remotes/origin/*')

  """
  如果指示了clone bundle方式，则尝试下载远端的clone.bundle到本地，然后导入下载的clone.bundle文件。

  对远程remote的orgin源执行'git fetch'操作。

  这里要注意的是，即使是clone bundle的方式，在导入clone.bundle文件后，依然执行'git fetch'，这样确保了本地是最新的代码。
  """
  if clone_bundle and _DownloadBundle(url, local, quiet):
    _ImportBundle(local)
  _Fetch(url, local, 'origin', quiet)


def _Verify(cwd, branch, quiet):
  """Verify the branch has been signed by a tag.
  """
  cmd = [GIT, 'describe', 'origin/%s' % branch]
  proc = subprocess.Popen(cmd,
                          stdout=subprocess.PIPE,
                          stderr=subprocess.PIPE,
                          cwd=cwd)
  cur = proc.stdout.read().strip()
  proc.stdout.close()

  proc.stderr.read()
  proc.stderr.close()

  if proc.wait() != 0 or not cur:
    _print(file=sys.stderr)
    _print("fatal: branch '%s' has not been signed" % branch, file=sys.stderr)
    raise CloneFailure()

  m = re.compile(r'^(.*)-[0-9]{1,}-g[0-9a-f]{1,}$').match(cur)
  if m:
    cur = m.group(1)
    if not quiet:
      _print(file=sys.stderr)
      _print("info: Ignoring branch '%s'; using tagged release '%s'"
             % (branch, cur), file=sys.stderr)
      _print(file=sys.stderr)

  env = os.environ.copy()
  try:
    env['GNUPGHOME'] = gpg_dir
  except UnicodeEncodeError:
    env['GNUPGHOME'] = gpg_dir.encode()

  cmd = [GIT, 'tag', '-v', cur]
  proc = subprocess.Popen(cmd,
                          stdout=subprocess.PIPE,
                          stderr=subprocess.PIPE,
                          cwd=cwd,
                          env=env)
  out = proc.stdout.read()
  proc.stdout.close()

  err = proc.stderr.read()
  proc.stderr.close()

  if proc.wait() != 0:
    _print(file=sys.stderr)
    _print(out, file=sys.stderr)
    _print(err, file=sys.stderr)
    _print(file=sys.stderr)
    raise CloneFailure()
  return '%s^0' % cur


def _Checkout(cwd, branch, rev, quiet):
  """Checkout an upstream branch into the repository and track it.
  """
  """
  整个_Checkout()操作依次执行以下操作：
  1. 'git update-ref refs/heads/default rev'
  2. 'git config branch.default.remote origin'
  3. 'git config branch.default.merge refs/heads/branch'
  4. 'git symbolic-ref HEAD refs/heads/default'
  5. 'git read-tree --reset -u -v HEAD'
  """
  cmd = [GIT, 'update-ref', 'refs/heads/default', rev]
  if subprocess.Popen(cmd, cwd=cwd).wait() != 0:
    raise CloneFailure()

  _SetConfig(cwd, 'branch.default.remote', 'origin')
  _SetConfig(cwd, 'branch.default.merge', 'refs/heads/%s' % branch)

  cmd = [GIT, 'symbolic-ref', 'HEAD', 'refs/heads/default']
  if subprocess.Popen(cmd, cwd=cwd).wait() != 0:
    raise CloneFailure()

  cmd = [GIT, 'read-tree', '--reset', '-u']
  if not quiet:
    cmd.append('-v')
  cmd.append('HEAD')
  if subprocess.Popen(cmd, cwd=cwd).wait() != 0:
    raise CloneFailure()


"""
查找repo的安装路径, 返回'.repo/mani.py'文件和'.repo'目录的完整路径

以'/public/test'目录为例，返回如下内容:
  ('/public/test/.repo/repo/main.py', '/public/test/.repo')

操作上从当前目录开始逐级向外层查找'.repo/main.py'文件，直到根'/'目录为止。
"""
def _FindRepo():
  """Look for a repo installation, starting at the current directory.
  """
  curdir = os.getcwd()
  repo = None

  olddir = None
  while curdir != '/' \
          and curdir != olddir \
          and not repo:
    """
    repo = curdir/.repo/repo/main.py
    向外逐级检查repo指定文件是否存在
    """
    repo = os.path.join(curdir, repodir, REPO_MAIN)
    if not os.path.isfile(repo):
      repo = None
      olddir = curdir
      curdir = os.path.dirname(curdir)
  """
  返回'.repo/main.py'文件和'.repo'目录的完整路径, 如:
  ('/public/test/.repo/repo/main.py', '/public/test/.repo')
  """
  return (repo, os.path.join(curdir, repodir))


class _Options(object):
  help = False


"""
解析args参数的选项

命令参数主要有两部分组成, 如:
args = ['init', '-u', 'https://android.googlesource.com/platform/manifest', '-b', 'android-4.0.1_r1']
则:
cmd = 'init'
arg = ['-u', 'https://android.googlesource.com/platform/manifest', '-b', 'android-4.0.1_r1']

如果args中包含'-h'或'--help'项, 则opt.help=True
"""
def _ParseArguments(args):
  cmd = None
  opt = _Options()
  arg = []

  for i in range(len(args)):
    a = args[i]
    if a == '-h' or a == '--help':
      opt.help = True
    """
    cmd为args中第一个不以'-'开头的项，其余项都作为arg
    """
    elif not a.startswith('-'):
      cmd = a
      arg = args[i + 1:]
      break
  return cmd, opt, arg


"""
显示没有安装repo时简单的帮助信息

'''
usage: repo COMMAND [ARGS]

repo is not yet installed.  Use "repo init" to install it here.

The most commonly used repo commands are:

  init      Install repo in the current working directory
  help      Display detailed help on a command

For access to the full online help, install repo ("repo init").
'''
"""
def _Usage():
  gitc_usage = ""
  if get_gitc_manifest_dir():
    gitc_usage = "  gitc-init Initialize a GITC Client.\n"

  _print(
      """usage: repo COMMAND [ARGS]

repo is not yet installed.  Use "repo init" to install it here.

The most commonly used repo commands are:

  init      Install repo in the current working directory
""" + gitc_usage +
      """  help      Display detailed help on a command

For access to the full online help, install repo ("repo init").
""", file=sys.stderr)
  sys.exit(1)


"""
显示init或gitc-init命令的帮助信息

$ repo init -h
Usage: repo init -u url [options]


Options:
  -h, --help            show this help message and exit

  Logging options:
    -q, --quiet         be quiet

  Manifest options:
    -u URL, --manifest-url=URL
                        manifest repository location
    -b REVISION, --manifest-branch=REVISION
                        manifest branch or revision
    -m NAME.xml, --manifest-name=NAME.xml
                        initial manifest file
    --mirror            create a replica of the remote repositories rather
                        than a client working directory
    --reference=DIR     location of mirror directory
    --depth=DEPTH       create a shallow clone with given depth; see git clone
    --archive           checkout an archive instead of a git repository for
                        each project. See git archive.
    -g GROUP, --groups=GROUP
                        restrict manifest projects to ones with specified
                        group(s) [default|all|G1,G2,G3|G4,-G5,-G6]
    -p PLATFORM, --platform=PLATFORM
                        restrict manifest projects to ones with a specified
                        platform group [auto|all|none|linux|darwin|...]
    --no-clone-bundle   disable use of /clone.bundle on HTTP/HTTPS

  repo Version options:
    --repo-url=URL      repo repository location
    --repo-branch=REVISION
                        repo branch or revision
    --no-repo-verify    do not verify repo source code

  Other options:
    --config-name       Always prompt for name/e-mail

$ repo gitc-init -h
Usage: repo gitc-init -u url -c client [options]

Options:
  -h, --help            show this help message and exit

  ...gitc-init的这部分帮助信息与init的帮助信息一样...

  GITC options:
    -f MANIFEST_FILE, --manifest-file=MANIFEST_FILE
                        Optional manifest file to use for this GITC client.
    -c GITC_CLIENT, --gitc-client=GITC_CLIENT
                        The name of the gitc_client instance to create or
                        modify.
"""
def _Help(args):
  if args:
    if args[0] == 'init':
      init_optparse.print_help()
      sys.exit(0)
    elif args[0] == 'gitc-init':
      _GitcInitOptions(init_optparse)
      init_optparse.print_help()
      sys.exit(0)
    else:
      _print("error: '%s' is not a bootstrap command.\n"
             '        For access to online help, install repo ("repo init").'
             % args[0], file=sys.stderr)
  else:
    _Usage()
  sys.exit(1)


"""
显示repo库没有安装的错误信息

如下:
$ repo
error: repo is not installed.  Use "repo init" to install it here.
"""
def _NotInstalled():
  _print('error: repo is not installed.  Use "repo init" to install it here.',
         file=sys.stderr)
  sys.exit(1)


"""
显示找不到命令的错误信息

如下:
$ repo sync
error: command 'sync' requires repo to be installed first.
         Use "repo init" to install it here.
"""
def _NoCommands(cmd):
  _print("""error: command '%s' requires repo to be installed first.
         Use "repo init" to install it here.""" % cmd, file=sys.stderr)
  sys.exit(1)


"""
检查wrapper_path对应的路径下是否存在一个完整的repo库

如果是，就返回repo库下'main.py'文件和'.git'目录的路径，否则返回空。
"""
def _RunSelf(wrapper_path):
  """
  有wrapper_path有两种可能的情况，单独的repo脚本或完整的repo库。

  1. 单独的repo脚本，如: wrapper_path = /home/rg935739/bin/repo, 则:
  my_dir  = /home/rg935739/bin
  my_main = /home/rg935739/bin/main.py
  my_git  = /home/rg935739/bin/.git

  2. 完整的repo库，如: wrapper_path = /path/to/test/.repo/repo/repo, 则:
  my_dir  = /path/to/test/.repo/repo
  my_main = /path/to/test/.repo/repo/main.py
  my_git  = /path/to/test/.repo/repo/.git
  """
  my_dir = os.path.dirname(wrapper_path)
  my_main = os.path.join(my_dir, 'main.py')
  my_git = os.path.join(my_dir, '.git')

  """
  检查是否是一个完整的repo库

  如果wrapper_path对应路径下'main.py', '.git'和其它的'git_config.py', 'project.py'以及'subcmds'都存在，
  说明当前是一个完整的repo库，而不是一个单独的'repo'脚本。
  """
  if os.path.isfile(my_main) and os.path.isdir(my_git):
    for name in ['git_config.py',
                 'project.py',
                 'subcmds']:
      if not os.path.exists(os.path.join(my_dir, name)):
        return None, None
    return my_main, my_git
  return None, None


def _SetDefaultsTo(gitdir):
  global REPO_URL
  global REPO_REV

  """
  执行：'git --git-dir=/path/to/test/.repo/repo/.git symbolic-ref HEAD'
  """
  REPO_URL = gitdir
  proc = subprocess.Popen([GIT,
                           '--git-dir=%s' % gitdir,
                           'symbolic-ref',
                           'HEAD'],
                          stdout=subprocess.PIPE,
                          stderr=subprocess.PIPE)
  REPO_REV = proc.stdout.read().strip()
  proc.stdout.close()

  proc.stderr.read()
  proc.stderr.close()

  if proc.wait() != 0:
    _print('fatal: %s has no current branch' % gitdir, file=sys.stderr)
    sys.exit(1)


"""
脚本的main函数，执行'repo'脚本时会通过'__main__'入口转到main函数

如:'repo init -u https://android.googlesource.com/platform/manifest -b android-4.0.1_r1'
'__main__'入口调用: main(['init', '-u', 'https://android.googlesource.com/platform/manifest', '-b', 'android-4.0.1_r1'])
"""
def main(orig_args):
  """
  由_ParseArguments(args)可知，任何一个args都由两部分组成，即前面的cmd部分和cmd后面的arg部分。
  如果参数args中包含'-h'或'-help'项，则返回结果中opt.help = True

  解析列表参数orig_args，对于上面的'init'命令:
  orig_args = ['init', '-u', 'https://android.googlesource.com/platform/manifest', '-b', 'android-4.0.1_r1']

  解析返回的结果为：
  - cmd: 'init'
  - arg: ['-u', 'https://android.googlesource.com/platform/manifest', '-b', 'android-4.0.1_r1']
  - opt.help = False
  """
  cmd, opt, args = _ParseArguments(orig_args)

  repo_main, rel_repo_dir = None, None
  # Don't use the local repo copy, make sure to switch to the gitc client first.
  if cmd != 'gitc-init':
    repo_main, rel_repo_dir = _FindRepo()

  """
  名称为'repo'的脚本至少在两个地方存在：
  1. 用户下载的repo脚本，通常位于主目录bin文件夹下，如: /home/rg935739/bin/repo
  2. 'repo init'初始化以后下载的repo库中的repo脚本: '.repo/repo/repo'

  使用os.path.abspath(__file__)来获取当前执行脚本的绝对路径。

  'repo COMMAND'命令通常引用的是用户主目录bin文件夹下的repo。

  通过_RunSelf(wrapper_path)调用确认当前执行的是单独的repo脚本还是完整repo库下的repo脚本。
  - 如果是完整的repo库，则my_main和my_git分别返回repo库下'main.py'文件和'.git'目录的路径，以备后续使用。
  - 如果是单独的repo脚本，则my_main和my_git返回值都是None。
  """
  wrapper_path = os.path.abspath(__file__)
  my_main, my_git = _RunSelf(wrapper_path)

  cwd = os.getcwd()
  if get_gitc_manifest_dir() and cwd.startswith(get_gitc_manifest_dir()):
    _print('error: repo cannot be used in the GITC local manifest directory.'
           '\nIf you want to work on this GITC client please rerun this '
           'command from the corresponding client under /gitc/',
           file=sys.stderr)
    sys.exit(1)

  """
  如果是单独repo脚本的情况，有几种操作:
  - 参数中带有'-h'或'-help'，显示repo脚本简单的帮助信息
  - 参数中带有'init'或'gitc-init'命令，调用_Init()下载repo库到本地
    例如前面的'repo init'命令，这里的调用为:
    _Init(args=['-u', 'https://android.googlesource.com/platform/manifest', '-b', 'android-4.0.1_r1'], ...)
  - 参数中不带命令，或没有找到相应命令，显示相应的提示信息
  """
  if not repo_main:
    if opt.help:
      _Usage()
    if cmd == 'help':
      _Help(args)
    if not cmd:
      _NotInstalled()
    if cmd == 'init' or cmd == 'gitc-init':
      if my_git:
        _SetDefaultsTo(my_git)
      try:
        """
        调用: _Init(args=['-u', 'https://android.googlesource.com/platform/manifest', '-b', 'android-4.0.1_r1'], ...)
        """
        _Init(args, gitc_init=(cmd == 'gitc-init'))
      except CloneFailure:
        """
        下载repo库失败时，会删除整个'.repo'目录
        """
        shutil.rmtree(os.path.join(repodir, S_repo), ignore_errors=True)
        sys.exit(1)
      """
      下载repo成功后:
      repo_main    = '.repo/mani.py'文件路径
      rel_repo_dir = '.repo'目录路径
      """
      repo_main, rel_repo_dir = _FindRepo()
    else:
      _NoCommands(cmd)

  """
  repo_main是在下载repo库后设置的。
  在已经存在repo的情况下，不会再次下载repo库，也就不会设置repo_main，所以这里需要用my_main设置repo_main。
  """
  if my_main:
    repo_main = my_main

  """
  到这里就已经准备好repo库了，意味着所有的repo命令都可转到’.repo/repo/main.py'脚本运行了。

  这里将repo命令打包转发到'.repo/repo/main.py'脚本去执行，例如：

  命令:'repo init -u https://android.googlesource.com/platform/manifest -b android-4.0.1_r1'
  最终构建的me如下：
    ['/usr/bin/python',
        '/path/to/test/.repo/repo/main.py',
        '--repo-dir=/path/to/test/.repo',
        '--wrapper-version=1.23',
        '--wrapper-path=/home/rg935739/bin/repo',
        '--',
        'init', '-u', 'https://android.googlesource.com/platform/manifest', '-b', 'android-4.0.1_r1',
        '--repo-url=https://gerrit.googlesource.com/git-repo',
        '--repo-branch=stable']

  命令:'repo sync'
  最终构建me如下：
    ['/usr/bin/python',
        '/path/to/test/.repo/repo/main.py',
        '--repo-dir=/path/to/test/.repo',
        '--wrapper-version=1.23',
        '--wrapper-path=/home/rg935739/bin/repo',
        '--',
        'sync']

  所以剩下的事情都交给'.repo/repo/main.py'脚本了。
  """
  ver_str = '.'.join(map(str, VERSION))
  me = [sys.executable, repo_main,
        '--repo-dir=%s' % rel_repo_dir,
        '--wrapper-version=%s' % ver_str,
        '--wrapper-path=%s' % wrapper_path,
        '--']
  me.extend(orig_args)
  me.extend(extra_args)
  try:
    os.execv(sys.executable, me)
  except OSError as e:
    _print("fatal: unable to start %s" % repo_main, file=sys.stderr)
    _print("fatal: %s" % e, file=sys.stderr)
    sys.exit(148)


"""
repo命令入口，以android官方的'init'命令为例:
  'repo init -u https://android.googlesource.com/platform/manifest -b android-4.0.1_r1'
"""
if __name__ == '__main__':

  """
  提示仅支持python2版本
  """
  if ver[0] == 3:
    _print('warning: Python 3 support is currently experimental. YMMV.\n'
           'Please use Python 2.6 - 2.7 instead.',
           file=sys.stderr)
  """
  如:'repo init -u https://android.googlesource.com/platform/manifest -b android-4.0.1_r1'
  则: argv = ['repo', 'init', '-u', 'https://android.googlesource.com/platform/manifest', '-b', 'android-4.0.1_r1']

  最后main函数调用为:
  main(['init', '-u', 'https://android.googlesource.com/platform/manifest', '-b', 'android-4.0.1_r1'])
  """
  main(sys.argv[1:])
