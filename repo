在开始分析repo脚本前，有必要先浏览下整个脚本文件的结构。 
整个脚本文件共886行，分为3个部分：
- 第一部分，第1~222行，主要是定义了脚本中使用的常量和一些repo命令行选项
- 第二部分，第223~875行，分别定义了脚本中可能需要使用的各个函数
- 第三部分，第878~883行，定义了repo脚本作为单独文件执行的入口，命令行执行`repo xxx`从这里开始

```
  1 #!/usr/bin/env python
  2
```
第1行：通过env方式来指定python解释器，可以避免因为python安装到不同位置而找不到解释器的情况

``` 
  3 # repo default configuration
  4 #
  5 import os
  6 REPO_URL = os.environ.get('REPO_URL', None)
  7 if not REPO_URL:
  8   REPO_URL = 'https://gerrit.googlesource.com/git-repo'
  9 REPO_REV = 'stable'
 10
```
第3~10行：设置REPO_URL和REPO_REV
  - REPO_URL: 先尝试获取环境变量'REPO_URL'的值，如果没有设置，则使用google官方的地址
  - REPO_REV: 使用stable分支
如果你被墙了，无法上谷歌去获取repo库，可以：
  1. 通过设置环境变量REPO_URL来指定，
  2. 或在这里将REPO_URL指向你局域网或本地的repo库。

``` 
 11 # Copyright (C) 2008 Google Inc.
 12 #
 13 # Licensed under the Apache License, Version 2.0 (the "License");
 14 # you may not use this file except in compliance with the License.
 15 # You may obtain a copy of the License at
 16 #
 17 #      http://www.apache.org/licenses/LICENSE-2.0
 18 #
 19 # Unless required by applicable law or agreed to in writing, software
 20 # distributed under the License is distributed on an "AS IS" BASIS,
 21 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 22 # See the License for the specific language governing permissions and
 23 # limitations under the License.
 24 
```
第11~24行：一大堆版权信息

```
 25 # increment this whenever we make important changes to this script
 26 VERSION = (1, 23)
 27 
 28 # increment this if the MAINTAINER_KEYS block is modified
 29 KEYRING_VERSION = (1, 2)
 30 
 31 # Each individual key entry is created by using:
 32 # gpg --armor --export keyid
 33 MAINTAINER_KEYS = """
 34 
 35      Repo Maintainer <repo@android.kernel.org>
 36 -----BEGIN PGP PUBLIC KEY BLOCK-----
 37 Version: GnuPG v1.4.2.2 (GNU/Linux)
 38 
 39 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
 74 =CMiZ
 75 -----END PGP PUBLIC KEY BLOCK-----
 76 
 77      Conley Owens <cco3@android.com>
 78 -----BEGIN PGP PUBLIC KEY BLOCK-----
 79 Version: GnuPG v1.4.11 (GNU/Linux)
 80 
 81 mQENBFHRvc8BCADFg45Xx/y6QDC+T7Y/gGc7vx0ww7qfOwIKlAZ9xG3qKunMxo+S
 82 hPCnzEl3cq+6I1Ww/ndop/HB3N3toPXRCoN8Vs4/Hc7by+SnaLFnacrm+tV5/OgT
 83 V37Lzt8lhay1Kl+YfpFwHYYpIEBLFV9knyfRXS/428W2qhdzYfvB15/AasRmwmor
 84 py4NIzSs8UD/SPr1ihqNCdZM76+MQyN5HMYXW/ALZXUFG0pwluHFA7hrfPG74i8C
 85 zMiP7qvMWIl/r/jtzHioH1dRKgbod+LZsrDJ8mBaqsZaDmNJMhss9g76XvfMyLra
 86 9DI9/iFuBpGzeqBv0hwOGQspLRrEoyTeR6n1ABEBAAG0H0NvbmxleSBPd2VucyA8
 87 Y2NvM0BhbmRyb2lkLmNvbT6JATgEEwECACIFAlHRvc8CGwMGCwkIBwMCBhUIAgkK
 88 CwQWAgMBAh4BAheAAAoJEGe35EhpKzgsP6AIAJKJmNtn4l7hkYHKHFSo3egb6RjQ
 89 zEIP3MFTcu8HFX1kF1ZFbrp7xqurLaE53kEkKuAAvjJDAgI8mcZHP1JyplubqjQA
 90 xvv84gK+OGP3Xk+QK1ZjUQSbjOpjEiSZpRhWcHci3dgOUH4blJfByHw25hlgHowd
 91 a/2PrNKZVcJ92YienaxxGjcXEUcd0uYEG2+rwllQigFcnMFDhr9B71MfalRHjFKE
 92 fmdoypqLrri61YBc59P88Rw2/WUpTQjgNubSqa3A2+CKdaRyaRw+2fdF4TdR0h8W
 93 zbg+lbaPtJHsV+3mJC7fq26MiJDRJa5ZztpMn8su20gbLgi2ShBOaHAYDDi5AQ0E
 94 UdG9zwEIAMoOBq+QLNozAhxOOl5GL3StTStGRgPRXINfmViTsihrqGCWBBUfXlUE
 95 OytC0mYcrDUQev/8ToVoyqw+iGSwDkcSXkrEUCKFtHV/GECWtk1keyHgR10YKI1R
 96 mquSXoubWGqPeG1PAI74XWaRx8UrL8uCXUtmD8Q5J7mDjKR5NpxaXrwlA0bKsf2E
 97 Gp9tu1kKauuToZhWHMRMqYSOGikQJwWSFYKT1KdNcOXLQF6+bfoJ6sjVYdwfmNQL
 98 Ixn8QVhoTDedcqClSWB17VDEFDFa7MmqXZz2qtM3X1R/MUMHqPtegQzBGNhRdnI2
 99 V45+1Nnx/uuCxDbeI4RbHzujnxDiq70AEQEAAYkBHwQYAQIACQUCUdG9zwIbDAAK
100 CRBnt+RIaSs4LNVeB/0Y2pZ8I7gAAcEM0Xw8drr4omg2fUoK1J33ozlA/RxeA/lJ
101 I3KnyCDTpXuIeBKPGkdL8uMATC9Z8DnBBajRlftNDVZS3Hz4G09G9QpMojvJkFJV
102 By+01Flw/X+eeN8NpqSuLV4W+AjEO8at/VvgKr1AFvBRdZ7GkpI1o6DgPe7ZqX+1
103 dzQZt3e13W0rVBb/bUgx9iSLoeWP3aq/k+/GRGOR+S6F6BBSl0SQ2EF2+dIywb1x
104 JuinEP+AwLAUZ1Bsx9ISC0Agpk2VeHXPL3FGhroEmoMvBzO0kTFGyoeT7PR/BfKv
105 +H/g3HsL2LOB9uoIm8/5p2TTU5ttYCXMHhQZ81AY
106 =AUp4
107 -----END PGP PUBLIC KEY BLOCK-----
108 """
109 
```
第25~109行：定义了当前repo脚本和KEYRING的版本，以及两个用于下载时验证的PGP Public Key

```
110 GIT = 'git'                      # our git command
111 MIN_GIT_VERSION = (1, 7, 2)      # minimum supported git version
112 repodir = '.repo'                # name of repo's private directory
113 S_repo = 'repo'                  # special repo repository
114 S_manifests = 'manifests'        # special manifest repository
115 REPO_MAIN = S_repo + '/main.py'  # main script
116 MIN_PYTHON_VERSION = (2, 6)      # minimum supported python version
117 GITC_CONFIG_FILE = '/gitc/.config'
118 GITC_FS_ROOT_DIR = '/gitc/manifest-rw/'
119 
120 
```
第110~118行：定义 repo 脚本中使用的一些其它常量，主要有两类：
  1. 版本相关，如 git最低版本，python最低版本等；
  2. 路径相关，如 repo私有目录名称、路径，manifests名称，gitc配置路径等
 
第110行使用GIT来替代'git'命令，这样比较灵活，可以通过替换 GIT = 'git -xxx' 来修改要执行的命令或给命令附加一些其它选项

```
121 import errno
122 import optparse
123 import re
124 import shutil
125 import stat
126 import subprocess
127 import sys
128 
129 if sys.version_info[0] == 3:
130   import urllib.request
131   import urllib.error
132 else:
133   import imp
134   import urllib2
135   urllib = imp.new_module('urllib')
136   urllib.request = urllib2
137   urllib.error = urllib2
138 
139 
```
第112~137行：导入脚本需要使用的模块

其中，第129行开始，检查python解释器的版本，根据不同版本对urllib进行不同的处理，为不同版本解释器访问urllib库使用统一的接口。
Python3中，urllib包含多个子模块：
- urllib.request
- urllib.error
- urllib.parse
- urllib.robotparser

Python2中，urllib和urllib2功能不同，这里使用imp.new_module('urllib')生成一个名为'urllib'空白库，然后将urllib2作为其request和error成员的实现，因此这里生成的urllib同系统自带的urllib库是不一样的，只是名字相同而已。
也可以理解为使用Python2现有库构造一个Python3使用方式一样的urllib库。

```
140 def _print(*objects, **kwargs):
141   sep = kwargs.get('sep', ' ')
142   end = kwargs.get('end', '\n')
143   out = kwargs.get('file', sys.stdout)
144   out.write(sep.join(objects) + end)
145 
146 
```
第140~144行：Python2和Python3的print函数不一样，无法直接使用，所以这里定义新的_print函数，用于打印输出信息。
也可以在python2分支通过 __future__ 模块来导入python3的print函数达到同样的效果：
```
from __future__ import print_function

# call print like in python3
# print('...')
```

```
147 # Python version check
    # 获取系统版本
148 ver = sys.version_info
    # 检查系统版本是否低于前面定义的2.6
149 if (ver[0], ver[1]) < MIN_PYTHON_VERSION:
150   _print('error: Python version %s unsupported.\n'
151          'Please use Python 2.6 - 2.7 instead.'
152          % sys.version.split(' ')[0], file=sys.stderr)
153   sys.exit(1)
154 
```
第147~153行：检查python版本，如果低于前面定义的2.6版本，则退出脚本执行。

```
    # 定义home_dot_repo，如：/home/guyongqiangx/.repoconfig
155 home_dot_repo = os.path.expanduser('~/.repoconfig')
    # 定义gpg_dir，如：/home/guyongqiangx/.repoconfig/gnupg
156 gpg_dir = os.path.join(home_dot_repo, 'gnupg')
157 
```
第155~156行：定义了repo使用的配置文件目录，以及配置目录下的gnupg路径。

```
158 extra_args = []
    # 使用optparse创建init子命令的选项
159 init_optparse = optparse.OptionParser(usage="repo init -u url [options]")
160 
161 # Logging
162 group = init_optparse.add_option_group('Logging options')
163 group.add_option('-q', '--quiet',
164                  dest="quiet", action="store_true", default=False,
165                  help="be quiet")
166 
167 # Manifest
168 group = init_optparse.add_option_group('Manifest options')
169 group.add_option('-u', '--manifest-url',
170                  dest='manifest_url',
171                  help='manifest repository location', metavar='URL')
172 group.add_option('-b', '--manifest-branch',
173                  dest='manifest_branch',
174                  help='manifest branch or revision', metavar='REVISION')
175 group.add_option('-m', '--manifest-name',
176                  dest='manifest_name',
177                  help='initial manifest file', metavar='NAME.xml')
178 group.add_option('--mirror',
179                  dest='mirror', action='store_true',
180                  help='create a replica of the remote repositories '
181                       'rather than a client working directory')
182 group.add_option('--reference',
183                  dest='reference',
184                  help='location of mirror directory', metavar='DIR')
185 group.add_option('--depth', type='int', default=None,
186                  dest='depth',
187                  help='create a shallow clone with given depth; see git clone')
188 group.add_option('--archive',
189                  dest='archive', action='store_true',
190                  help='checkout an archive instead of a git repository for '
191                       'each project. See git archive.')
192 group.add_option('-g', '--groups',
193                  dest='groups', default='default',
194                  help='restrict manifest projects to ones with specified '
195                       'group(s) [default|all|G1,G2,G3|G4,-G5,-G6]',
196                  metavar='GROUP')
197 group.add_option('-p', '--platform',
198                  dest='platform', default="auto",
199                  help='restrict manifest projects to ones with a specified '
200                       'platform group [auto|all|none|linux|darwin|...]',
201                  metavar='PLATFORM')
202 group.add_option('--no-clone-bundle',
203                  dest='no_clone_bundle', action='store_true',
204                  help='disable use of /clone.bundle on HTTP/HTTPS')
205 
206 
207 # Tool
208 group = init_optparse.add_option_group('repo Version options')
209 group.add_option('--repo-url',
210                  dest='repo_url',
211                  help='repo repository location', metavar='URL')
212 group.add_option('--repo-branch',
213                  dest='repo_branch',
214                  help='repo branch or revision', metavar='REVISION')
215 group.add_option('--no-repo-verify',
216                  dest='no_repo_verify', action='store_true',
217                  help='do not verify repo source code')
218 
219 # Other
220 group = init_optparse.add_option_group('Other options')
221 group.add_option('--config-name',
222                  dest='config_name', action="store_true", default=False,
223                  help='Always prompt for name/e-mail')
224 
225 
```
第158~223行：定义了repo子命令'init'的参数选项init_optparse，看起来很乱，实际上很简单，主要包括4组：
  - Logging options
    - '-q'
  - Manifest options
    - '-u'
    - '-b'
    - '-m'
    - '--mirror'
    - '--reference'
    - '--depth'
    - '--archive'
    - '-g'
    - '-p'
    - '--no-clone-bundle'
  - Tool/repo Version options
    - '--repo-url'
    - '--repo-branch'
    - '--no-repo-verify'
  - Other options
    - '--config-name'
可以在命令行执行`repo init -h`查看最终生成的帮助信息：
```
$ repo init -h
Usage: repo init -u url [options]

Options:
  -h, --help            show this help message and exit

  Logging options:
    -q, --quiet         be quiet

  Manifest options:
    -u URL, --manifest-url=URL
                        manifest repository location
    -b REVISION, --manifest-branch=REVISION
                        manifest branch or revision
    -m NAME.xml, --manifest-name=NAME.xml
                        initial manifest file
    --mirror            create a replica of the remote repositories rather
                        than a client working directory
    --reference=DIR     location of mirror directory
    --depth=DEPTH       create a shallow clone with given depth; see git clone
    --archive           checkout an archive instead of a git repository for
                        each project. See git archive.
    -g GROUP, --groups=GROUP
                        restrict manifest projects to ones with specified
                        group(s) [default|all|G1,G2,G3|G4,-G5,-G6]
    -p PLATFORM, --platform=PLATFORM
                        restrict manifest projects to ones with a specified
                        platform group [auto|all|none|linux|darwin|...]
    --no-clone-bundle   disable use of /clone.bundle on HTTP/HTTPS

  repo Version options:
    --repo-url=URL      repo repository location
    --repo-branch=REVISION
                        repo branch or revision
    --no-repo-verify    do not verify repo source code

  Other options:
    --config-name       Always prompt for name/e-mail
```
选项的帮助信息比较清楚，其作用在分析`repo init`命令时进一步说明。

```
226 def _GitcInitOptions(init_optparse_arg):
227   init_optparse_arg.set_usage("repo gitc-init -u url -c client [options]")
228   g = init_optparse_arg.add_option_group('GITC options')
229   g.add_option('-f', '--manifest-file',
230                dest='manifest_file',
231                help='Optional manifest file to use for this GITC client.')
232   g.add_option('-c', '--gitc-client',
233                dest='gitc_client',
234                help='The name of the gitc_client instance to create or modify.')
235 
236 _gitc_manifest_dir = None
237 
238 
239 def get_gitc_manifest_dir():
240   global _gitc_manifest_dir
241   if _gitc_manifest_dir is None:
242     _gitc_manifest_dir = ''
243     try:
244       with open(GITC_CONFIG_FILE, 'r') as gitc_config:
245         for line in gitc_config:
246           match = re.match('gitc_dir=(?P<gitc_manifest_dir>.*)', line)
247           if match:
248             _gitc_manifest_dir = match.group('gitc_manifest_dir')
249     except IOError:
250       pass
251   return _gitc_manifest_dir
252 
253 
254 def gitc_parse_clientdir(gitc_fs_path):
255   """Parse a path in the GITC FS and return its client name.
256 
257   @param gitc_fs_path: A subdirectory path within the GITC_FS_ROOT_DIR.
258 
259   @returns: The GITC client name
260   """
261   if gitc_fs_path == GITC_FS_ROOT_DIR:
262     return None
263   if not gitc_fs_path.startswith(GITC_FS_ROOT_DIR):
264     manifest_dir = get_gitc_manifest_dir()
265     if manifest_dir == '':
266       return None
267     if manifest_dir[-1] != '/':
268       manifest_dir += '/'
269     if gitc_fs_path == manifest_dir:
270       return None
271     if not gitc_fs_path.startswith(manifest_dir):
272       return None
273     return gitc_fs_path.split(manifest_dir)[1].split('/')[0]
274   return gitc_fs_path.split(GITC_FS_ROOT_DIR)[1].split('/')[0]
275 
276 
```

    # 定义ConeFailure类，没有具体实现
277 class CloneFailure(Exception):
278 
279   """Indicate the remote clone of repo itself failed.
280   """
281 
282 
    # init子命令
283 def _Init(args, gitc_init=False):
284   """Installs repo by cloning it over the network.
285   """
286   if gitc_init:
287     _GitcInitOptions(init_optparse)
288   opt, args = init_optparse.parse_args(args)
289   if args:
290     init_optparse.print_usage()
291     sys.exit(1)
292 
293   url = opt.repo_url
294   if not url:
295     url = REPO_URL
296     extra_args.append('--repo-url=%s' % url)
297 
298   branch = opt.repo_branch
299   if not branch:
300     branch = REPO_REV
301     extra_args.append('--repo-branch=%s' % branch)
302 
303   if branch.startswith('refs/heads/'):
304     branch = branch[len('refs/heads/'):]
305   if branch.startswith('refs/'):
306     _print("fatal: invalid branch name '%s'" % branch, file=sys.stderr)
307     raise CloneFailure()
308 
309   try:
310     if gitc_init:
311       gitc_manifest_dir = get_gitc_manifest_dir()
312       if not gitc_manifest_dir:
313         _print('fatal: GITC filesystem is not available. Exiting...',
314                file=sys.stderr)
315         sys.exit(1)
316       gitc_client = opt.gitc_client
317       if not gitc_client:
318         gitc_client = gitc_parse_clientdir(os.getcwd())
319       if not gitc_client:
320         _print('fatal: GITC client (-c) is required.', file=sys.stderr)
321         sys.exit(1)
322       client_dir = os.path.join(gitc_manifest_dir, gitc_client)
323       if not os.path.exists(client_dir):
324         os.makedirs(client_dir)
325       os.chdir(client_dir)
326       if os.path.exists(repodir):
327         # This GITC Client has already initialized repo so continue.
328         return
329 
330     os.mkdir(repodir)
331   except OSError as e:
332     if e.errno != errno.EEXIST:
333       _print('fatal: cannot make %s directory: %s'
334              % (repodir, e.strerror), file=sys.stderr)
335       # Don't raise CloneFailure; that would delete the
336       # name. Instead exit immediately.
337       #
338       sys.exit(1)
339 
340   _CheckGitVersion()
341   try:
342     if NeedSetupGnuPG():
343       can_verify = SetupGnuPG(opt.quiet)
344     else:
345       can_verify = True
346 
347     dst = os.path.abspath(os.path.join(repodir, S_repo))
348     _Clone(url, dst, opt.quiet, not opt.no_clone_bundle)
349 
350     if can_verify and not opt.no_repo_verify:
351       rev = _Verify(dst, branch, opt.quiet)
352     else:
353       rev = 'refs/remotes/origin/%s^0' % branch
354 
355     _Checkout(dst, branch, rev, opt.quiet)
356   except CloneFailure:
357     if opt.quiet:
358       _print('fatal: repo init failed; run without --quiet to see why',
359              file=sys.stderr)
360     raise
361 
362 
```

```
    # 解析命令'git --version'返回的字符串，如：'git version 1.9.1'
363 def ParseGitVersion(ver_str):
      # 检查是否以 'git version'开头
364   if not ver_str.startswith('git version '):
365     return None
366 
      # 获取 'git version 1.9.1'后面指示版本的数字部分，如'1.9.1'
      # 不清楚这里为什么会使用'-'进行分割？某些版本存在类似'1.9.1-xxxx'的字符串么？
367   num_ver_str = ver_str[len('git version '):].strip().split('-')[0]
368   to_tuple = []
      # 对'1.9.1'使用'.'进行分割，并获取前面3项，即'1', '9', '1'
369   for num_str in num_ver_str.split('.')[:3]:
370     if num_str.isdigit():
371       to_tuple.append(int(num_str))
372     else:
373       to_tuple.append(0)
      # 返回获取的数字版本，如(1, 9, 1)
374   return tuple(to_tuple)
375 
376 
    # 运行'git --version'命令，并检查其版本
377 def _CheckGitVersion():
      # 构造'git --version'命令
378   cmd = [GIT, '--version']
379   try:
        # 执行'git --version'命令，并通过stdout=subprocess.PIPE设置接收命令输出
380     proc = subprocess.Popen(cmd, stdout=subprocess.PIPE)
381   except OSError as e: # 没有安装git时，命令执行出错
382     _print(file=sys.stderr)
383     _print("fatal: '%s' is not available" % GIT, file=sys.stderr)
384     _print('fatal: %s' % e, file=sys.stderr)
385     _print(file=sys.stderr)
386     _print('Please make sure %s is installed and in your path.' % GIT,
387            file=sys.stderr)
        # 将错误抛给外层
388     raise CloneFailure()
389 

      # 从管道的标准输出获取git版本字符串，如：'git version 1.9.1'
390   ver_str = proc.stdout.read().strip()
      # 关闭管道
391   proc.stdout.close()
392   proc.wait()
393 
      # 解析前面取得的字符串，如：'git version 1.9.1'，解析后返回(1,9,1)
394   ver_act = ParseGitVersion(ver_str)
      # 解析版本失败（如果字符串不是以'git version'开头就会失败）
395   if ver_act is None:
396     _print('error: "%s" unsupported' % ver_str, file=sys.stderr)
397     raise CloneFailure()
398 
      # 检查当前获得的版本是否低于前面定义的最低版本(1,7,2)
399   if ver_act < MIN_GIT_VERSION:
400     need = '.'.join(map(str, MIN_GIT_VERSION))
        # 提示支持的最低版本1.7.2
401     _print('fatal: git %s or later required' % need, file=sys.stderr)
402     raise CloneFailure()
403 
404 
```
第363~402行：定义了两个函数ParseGitVersion和_CheckGitVersion用于检查git版本是否低于(1,7,2)

```
    # 读取 '~/.repoconfig/keyring-version'文件并检查版本是否低于1.2
    # 读取失败或版本低于1.2，都需要重新设置PGP Key
405 def NeedSetupGnuPG():
      # 检查 '~/.repoconfig' 是否为目录 (有两种情况: 1. 不存在；2. 存在，但不是目录)
      # 如果 '~/.repoconfig' 目录不存在，则返回True，表明需要设置PGP Key
406   if not os.path.isdir(home_dot_repo):
407     return True
408 
      # 检查 '~/.repoconfig/keyring-version'文件
409   kv = os.path.join(home_dot_repo, 'keyring-version')
410   if not os.path.exists(kv):
411     return True
412 
      # 读取 '~/.repoconfig/keyring-version'文件
413   kv = open(kv).read()
414   if not kv:
415     return True
416 
      # 获取Keyring版本，并检查是否低于第29行定义的1.2
417   kv = tuple(map(int, kv.split('.')))
418   if kv < KEYRING_VERSION:
419     return True
420   return False
421 
422 
423 def SetupGnuPG(quiet):
      # 尝试生成目录 '~/.repoconfig'
424   try:
425     os.mkdir(home_dot_repo)
426   except OSError as e:
427     if e.errno != errno.EEXIST:
428       _print('fatal: cannot make %s directory: %s'
429              % (home_dot_repo, e.strerror), file=sys.stderr)
430       sys.exit(1)
431 
      # 尝试以S_IRWXU权限生成 '~/.repoconfig/gnupg'目录
432   try:
433     os.mkdir(gpg_dir, stat.S_IRWXU)
434   except OSError as e:
435     if e.errno != errno.EEXIST:
436       _print('fatal: cannot make %s directory: %s' % (gpg_dir, e.strerror),
437              file=sys.stderr)
438       sys.exit(1)
439 
      # 获取环境变量的一个副本进行改变，并只影响接下来使用这个env的线程
440   env = os.environ.copy()
      # 添加'GNUPGHOME'环境变量
441   try:
442     env['GNUPGHOME'] = gpg_dir
443   except UnicodeEncodeError:
444     env['GNUPGHOME'] = gpg_dir.encode()
445 
      # 执行'pgp --import'命令
446   cmd = ['gpg', '--import']
      # 使用stdin=subprocess.PIPE建立管道通信，通过管道stdin向执行的命令提供输入
447   try:
448     proc = subprocess.Popen(cmd,
449                             env=env,
450                             stdin=subprocess.PIPE)
451   except OSError as e:
452     if not quiet:
453       _print('warning: gpg (GnuPG) is not available.', file=sys.stderr)
454       _print('warning: Installing it is strongly encouraged.', file=sys.stderr)
455       _print(file=sys.stderr)
456     return False
457 
      # 由于前面Popen时指定了stdin=subprocess.PIPE，所以这里可以通过管道输入数据
      # 将 MAINTAINER_KEYS 作为 'gpg --import'的输入数据，类似：'gpt --import $MAINTAINER_KEYS'
458   proc.stdin.write(MAINTAINER_KEYS)
459   proc.stdin.close()
460 
      # 等待'gpt --import'命令执行结束
461   if proc.wait() != 0:
462     _print('fatal: registering repo maintainer keys failed', file=sys.stderr)
463     sys.exit(1)
464   _print()
465 
      # 往 '~/.repoconfig/keyring-version' 写入版本 1.2
466   fd = open(os.path.join(home_dot_repo, 'keyring-version'), 'w')
467   fd.write('.'.join(map(str, KEYRING_VERSION)) + '\n')
468   fd.close()
469   return True
470 
471 
```
第405~471行：定义了NeedSetupGnuPG和SetupGnuPG两个函数，其中SetupGnuPG调用NeedSetupGnuPG检查设置导入第57~131行的PGP key数据

```
    # 执行 'git config xxxx'命令
472 def _SetConfig(local, name, value):
473   """Set a git configuration option to the specified value.
474   """
475   cmd = [GIT, 'config', name, value]
476   if subprocess.Popen(cmd, cwd=local).wait() != 0:
477     raise CloneFailure()
478 
479 
```
第472~477行：定义_SetConfig函数用于执行'git config xxxx'命令

```
480 def _InitHttp():
481   handlers = []
482 
483   mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()
484   try:
485     import netrc
486     n = netrc.netrc()
487     for host in n.hosts:
488       p = n.hosts[host]
489       mgr.add_password(p[1], 'http://%s/' % host, p[0], p[2])
490       mgr.add_password(p[1], 'https://%s/' % host, p[0], p[2])
491   except:  # pylint: disable=bare-except
492     pass
493   handlers.append(urllib.request.HTTPBasicAuthHandler(mgr))
494   handlers.append(urllib.request.HTTPDigestAuthHandler(mgr))
495 
496   if 'http_proxy' in os.environ:
497     url = os.environ['http_proxy']
498     handlers.append(urllib.request.ProxyHandler({'http': url, 'https': url}))
499   if 'REPO_CURL_VERBOSE' in os.environ:
500     handlers.append(urllib.request.HTTPHandler(debuglevel=1))
501     handlers.append(urllib.request.HTTPSHandler(debuglevel=1))
502   urllib.request.install_opener(urllib.request.build_opener(*handlers))
503 
504 
505 def _Fetch(url, local, src, quiet):
506   if not quiet:
507     _print('Get %s' % url, file=sys.stderr)
508 
509   cmd = [GIT, 'fetch']
510   if quiet:
511     cmd.append('--quiet')
512     err = subprocess.PIPE
513   else:
514     err = None
515   cmd.append(src)
516   cmd.append('+refs/heads/*:refs/remotes/origin/*')
517   cmd.append('refs/tags/*:refs/tags/*')
518 
519   proc = subprocess.Popen(cmd, cwd=local, stderr=err)
520   if err:
521     proc.stderr.read()
522     proc.stderr.close()
523   if proc.wait() != 0:
524     raise CloneFailure()
525 
526 
527 def _DownloadBundle(url, local, quiet):
528   if not url.endswith('/'):
529     url += '/'
530   url += 'clone.bundle'
531 
532   proc = subprocess.Popen(
533       [GIT, 'config', '--get-regexp', 'url.*.insteadof'],
534       cwd=local,
535       stdout=subprocess.PIPE)
536   for line in proc.stdout:
537     m = re.compile(r'^url\.(.*)\.insteadof (.*)$').match(line)
538     if m:
539       new_url = m.group(1)
540       old_url = m.group(2)
541       if url.startswith(old_url):
542         url = new_url + url[len(old_url):]
543         break
544   proc.stdout.close()
545   proc.wait()
546 
547   if not url.startswith('http:') and not url.startswith('https:'):
548     return False
549 
550   dest = open(os.path.join(local, '.git', 'clone.bundle'), 'w+b')
551   try:
552     try:
553       r = urllib.request.urlopen(url)
554     except urllib.error.HTTPError as e:
555       if e.code in [401, 403, 404, 501]:
556         return False
557       _print('fatal: Cannot get %s' % url, file=sys.stderr)
558       _print('fatal: HTTP error %s' % e.code, file=sys.stderr)
559       raise CloneFailure()
560     except urllib.error.URLError as e:
561       _print('fatal: Cannot get %s' % url, file=sys.stderr)
562       _print('fatal: error %s' % e.reason, file=sys.stderr)
563       raise CloneFailure()
564     try:
565       if not quiet:
566         _print('Get %s' % url, file=sys.stderr)
567       while True:
568         buf = r.read(8192)
569         if buf == '':
570           return True
571         dest.write(buf)
572     finally:
573       r.close()
574   finally:
575     dest.close()
576 
577 
578 def _ImportBundle(local):
579   path = os.path.join(local, '.git', 'clone.bundle')
580   try:
581     _Fetch(local, local, path, True)
582   finally:
583     os.remove(path)
584 
585 
586 def _Clone(url, local, quiet, clone_bundle):
587   """Clones a git repository to a new subdirectory of repodir
588   """
589   try:
590     os.mkdir(local)
591   except OSError as e:
592     _print('fatal: cannot make %s directory: %s' % (local, e.strerror),
593            file=sys.stderr)
594     raise CloneFailure()
595 
596   cmd = [GIT, 'init', '--quiet']
597   try:
598     proc = subprocess.Popen(cmd, cwd=local)
599   except OSError as e:
600     _print(file=sys.stderr)
601     _print("fatal: '%s' is not available" % GIT, file=sys.stderr)
602     _print('fatal: %s' % e, file=sys.stderr)
603     _print(file=sys.stderr)
604     _print('Please make sure %s is installed and in your path.' % GIT,
605            file=sys.stderr)
606     raise CloneFailure()
607   if proc.wait() != 0:
608     _print('fatal: could not create %s' % local, file=sys.stderr)
609     raise CloneFailure()
610 
611   _InitHttp()
612   _SetConfig(local, 'remote.origin.url', url)
613   _SetConfig(local,
614              'remote.origin.fetch',
615              '+refs/heads/*:refs/remotes/origin/*')
616   if clone_bundle and _DownloadBundle(url, local, quiet):
617     _ImportBundle(local)
618   _Fetch(url, local, 'origin', quiet)
619 
620 
621 def _Verify(cwd, branch, quiet):
622   """Verify the branch has been signed by a tag.
623   """
624   cmd = [GIT, 'describe', 'origin/%s' % branch]
625   proc = subprocess.Popen(cmd,
626                           stdout=subprocess.PIPE,
627                           stderr=subprocess.PIPE,
628                           cwd=cwd)
629   cur = proc.stdout.read().strip()
630   proc.stdout.close()
631 
632   proc.stderr.read()
633   proc.stderr.close()
634 
635   if proc.wait() != 0 or not cur:
636     _print(file=sys.stderr)
637     _print("fatal: branch '%s' has not been signed" % branch, file=sys.stderr)
638     raise CloneFailure()
639 
640   m = re.compile(r'^(.*)-[0-9]{1,}-g[0-9a-f]{1,}$').match(cur)
641   if m:
642     cur = m.group(1)
643     if not quiet:
644       _print(file=sys.stderr)
645       _print("info: Ignoring branch '%s'; using tagged release '%s'"
646              % (branch, cur), file=sys.stderr)
647       _print(file=sys.stderr)
648 
649   env = os.environ.copy()
650   try:
651     env['GNUPGHOME'] = gpg_dir
652   except UnicodeEncodeError:
653     env['GNUPGHOME'] = gpg_dir.encode()
654 
655   cmd = [GIT, 'tag', '-v', cur]
656   proc = subprocess.Popen(cmd,
657                           stdout=subprocess.PIPE,
658                           stderr=subprocess.PIPE,
659                           cwd=cwd,
660                           env=env)
661   out = proc.stdout.read()
662   proc.stdout.close()
663 
664   err = proc.stderr.read()
665   proc.stderr.close()
666 
667   if proc.wait() != 0:
668     _print(file=sys.stderr)
669     _print(out, file=sys.stderr)
670     _print(err, file=sys.stderr)
671     _print(file=sys.stderr)
672     raise CloneFailure()
673   return '%s^0' % cur
674 
675 
676 def _Checkout(cwd, branch, rev, quiet):
677   """Checkout an upstream branch into the repository and track it.
678   """
679   cmd = [GIT, 'update-ref', 'refs/heads/default', rev]
680   if subprocess.Popen(cmd, cwd=cwd).wait() != 0:
681     raise CloneFailure()
682 
683   _SetConfig(cwd, 'branch.default.remote', 'origin')
684   _SetConfig(cwd, 'branch.default.merge', 'refs/heads/%s' % branch)
685 
686   cmd = [GIT, 'symbolic-ref', 'HEAD', 'refs/heads/default']
687   if subprocess.Popen(cmd, cwd=cwd).wait() != 0:
688     raise CloneFailure()
689 
690   cmd = [GIT, 'read-tree', '--reset', '-u']
691   if not quiet:
692     cmd.append('-v')
693   cmd.append('HEAD')
694   if subprocess.Popen(cmd, cwd=cwd).wait() != 0:
695     raise CloneFailure()
696 
697 
698 def _FindRepo():
699   """Look for a repo installation, starting at the current directory.
700   """
701   curdir = os.getcwd()
702   repo = None
703 
704   olddir = None
705   while curdir != '/' \
706           and curdir != olddir \
707           and not repo:
708     repo = os.path.join(curdir, repodir, REPO_MAIN)
709     if not os.path.isfile(repo):
710       repo = None
711       olddir = curdir
712       curdir = os.path.dirname(curdir)
713   return (repo, os.path.join(curdir, repodir))
714 
715 
```

```
    # 定义辅助类_Options，其help成员用于指示命令行参数是否带有'-h'/'--help'选项
716 class _Options(object):
717   help = False
718 
719 
    # 解析main函数接收到的参数列表
    # args = ['init', '-u', 'https://android.googlesource.com/platform/manifest', '-b', 'android-4.0.1_r1']
720 def _ParseArguments(args):
721   cmd = None
722   opt = _Options()
723   arg = []
724 
      # 循环列表args的每一项
725   for i in range(len(args)):
726     a = args[i]
        # 如果是'-h'/'--help'，设置opt.help=True
727     if a == '-h' or a == '--help':
728       opt.help = True
729 
        # 将不以'-'开头的第一项项作为cmd
730     elif not a.startswith('-'):
731       cmd = a
732       arg = args[i + 1:]
          #找到不以'-h'开始的项后跳出for循环，所以这里仅将第一个不以'-'开始的项作为cmd
733       break
734   return cmd, opt, arg
735 
736
```
第716~734行：定义了参数解析函数_ParseArguments，将args分解为三类：cmd, opt和arg：
- cmd，指执行repo时的子命令
- opt，用于检查命令行是否带有'-h'或'--help'选项，如果带有，则会标记opt.help=True
- arg，执行repo命令时，除去子命令和'-h'/'--help'外的其余参数项

对于参数args = ['init', '-u', 'https://android.googlesource.com/platform/manifest', '-b', 'android-4.0.1_r1']，这里解析得到的结果是：
- cmd: 'init'
- opt.help = False
- arg: ['-u', 'https://android.googlesource.com/platform/manifest', '-b', 'android-4.0.1_r1']

``` 
737 def _Usage():
738   gitc_usage = ""
739   if get_gitc_manifest_dir():
740     gitc_usage = "  gitc-init Initialize a GITC Client.\n"
741 
742   _print(
743       """usage: repo COMMAND [ARGS]
744 
745 repo is not yet installed.  Use "repo init" to install it here.
746 
747 The most commonly used repo commands are:
748 
749   init      Install repo in the current working directory
750 """ + gitc_usage +
751       """  help      Display detailed help on a command
752 
753 For access to the full online help, install repo ("repo init").
754 """, file=sys.stderr)
755   sys.exit(1)
756 
757 
```

```
758 def _Help(args):
759   if args:
        # 'init'子命令的帮助，'repo init --help'
760     if args[0] == 'init':
761       init_optparse.print_help()
762       sys.exit(0)
        # 'gitc-init'子命令的帮助，'repo gitc-init --help'
763     elif args[0] == 'gitc-init':
764       _GitcInitOptions(init_optparse)
765       init_optparse.print_help()
766       sys.exit(0)
767     else:
768       _print("error: '%s' is not a bootstrap command.\n"
769              '        For access to online help, install repo ("repo init").'
770              % args[0], file=sys.stderr)
771   else:
772     _Usage()
773   sys.exit(1)
774 
775 
    # repo脚本没有安装的帮助提示信息
776 def _NotInstalled():
777   _print('error: repo is not installed.  Use "repo init" to install it here.',
778          file=sys.stderr)
779   sys.exit(1)
780 
781 
    # 没有找到repo命令的帮助提示信息
782 def _NoCommands(cmd):
783   _print("""error: command '%s' requires repo to be installed first.
784          Use "repo init" to install it here.""" % cmd, file=sys.stderr)
785   sys.exit(1)
786 
787 
```
第758~785行：定义了_Help, _NotInstalled和_NoCommands三个函数，用于显示帮助提示信息

```
    # 检查运行的是repo库自身的repo脚本还是'~/bin'目录下的repo脚本
    # 如果是repo库自身的repo脚本，则返回其下'main.py'文件和'.git'目录的路径
788 def _RunSelf(wrapper_path):
      # 返回wrapper_path路径的上层目录，如：/home/guyongqiangx/bin
789   my_dir = os.path.dirname(wrapper_path)
      # 构造'main.py'文件的完整路径，如：'/home/guyongqiangx/bin/main.py'
790   my_main = os.path.join(my_dir, 'main.py')
      # 构造'.git'目录的完整路径，如：'/home/guyongqiangx/bin/.git' 
791   my_git = os.path.join(my_dir, '.git')
792 
      #在文件'main.py'和目录'.git'存在的情况下继续检查其'git_config.py', 'project.py'和'subcmds'是否存在
793   if os.path.isfile(my_main) and os.path.isdir(my_git):
794     for name in ['git_config.py',
795                  'project.py',
796                  'subcmds']:
          # 指定检查的某个文件或目录不存在，认为这里执行的不是当前目录下的repo本身
797       if not os.path.exists(os.path.join(my_dir, name)):
798         return None, None
        # 运行到这里，说明前面指定的文件和目录都存在，执行的是repo库里的repo文件
        # 返回当前repo库下'main.py'和'.git'的路径
799     return my_main, my_git
      # 'main.py'和'.git'不存在的情况下，直接返回两个None
800   return None, None
801 
802 
```
第788~800行：定义了_RunSelf函数，主要用于检查当前执行的repo脚本是否是一个完整的repo库里的文件。
因为当完成repo库的clone后，repo脚本有两份：
- 一份在'~/bin/repo'
- 一份在clone的repo库的根目录下
对于repo库目录下的repo脚本，其同一目录下还有其它文件和目录，如：'main.py', '.git', 'git_config.py', 'project.py', 'subcmds'等，因此如果这些文件或目录存在，说明执行的是repo库里面的repo脚本

```
803 def _SetDefaultsTo(gitdir):
804   global REPO_URL
805   global REPO_REV
806 
      # 将指定的gitdir设置为REPO_URL复制的地址
807   REPO_URL = gitdir
      # 构造命令'git --git-dir=xxx/.git symbolic-ref HEAD'命令，并建立管道通信
      # 这里通过'git symbolic-ref HEAD'命令来获取当前HEAD的引用版本，'--git-dir=<path>' 参数指定库的位置。
      # 例如执行：'$ git symbolic-ref HEAD'，返回的结果是 'refs/heads/master'
808   proc = subprocess.Popen([GIT,
809                            '--git-dir=%s' % gitdir,
810                            'symbolic-ref',
811                            'HEAD'],
812                           stdout=subprocess.PIPE,
813                           stderr=subprocess.PIPE)
814   REPO_REV = proc.stdout.read().strip()
815   proc.stdout.close()
816 
817   proc.stderr.read()
818   proc.stderr.close()
819 
820   if proc.wait() != 0:
821     _print('fatal: %s has no current branch' % gitdir, file=sys.stderr)
822     sys.exit(1)
823 
824 
```
第803~822行：定义了_SetDefaultsTo函数，解析当前.git目录下的repo库，提取其路径和引用版本来设置REPO_URL和REPO_REV

```
    # 以android官方的init命令为例，则这里main函数收到的参数为：
    # orig_args = ['init', '-u', 'https://android.googlesource.com/platform/manifest', '-b', 'android-4.0.1_r1']
825 def main(orig_args):
      # 解析列表参数orig_args，对于'init'命令，解析返回的结果为：
      # - cmd: 'init'
      # - opt.help = False
      # - arg: ['-u', 'https://android.googlesource.com/platform/manifest', '-b', 'android-4.0.1_r1']
826   cmd, opt, args = _ParseArguments(orig_args)
827 
828   repo_main, rel_repo_dir = None, None
829   # Don't use the local repo copy, make sure to switch to the gitc client first.
830   if cmd != 'gitc-init':
831     repo_main, rel_repo_dir = _FindRepo()
832 
      # 使用__file__返回当前执行repo脚本所在的路径
      # 默认repo放在'~/bin'目录下，所以这里是'~/bin/repo'扩展后的路径
      # 例如：'/home/guyongqiangx/bin/repo'
833   wrapper_path = os.path.abspath(__file__)
      # 调用函数_RunSelf检查当前执行的repo脚本路径下是否有一个完整的repo库
      # 如果是完整的库，则返回其库下文件'main.py'和目录'.git'的路径
      # 如果不是完整的库，则返回结果是None
834   my_main, my_git = _RunSelf(wrapper_path)
835 
      # 获取当前路径
836   cwd = os.getcwd()
837   if get_gitc_manifest_dir() and cwd.startswith(get_gitc_manifest_dir()):
838     _print('error: repo cannot be used in the GITC local manifest directory.'
839            '\nIf you want to work on this GITC client please rerun this '
840            'command from the corresponding client under /gitc/',
841            file=sys.stderr)
842     sys.exit(1)
      # repo_main为空的情况，说明当前执行的repo脚本还没有一个完整的库
843   if not repo_main:
        # _ParseArguments会设置otp.help标志，用于指示是否需要显示帮助信息
844     if opt.help:
845       _Usage()
        # 好吧，这里还有个单独的'help'命令，跟带'-h'/'--help'选项还不一样
846     if cmd == 'help':
847       _Help(args)
        # 'repo'执行不带命令的情况，显示相关帮助信息，并显示没有安装repo库的信息
848     if not cmd:
849       _NotInstalled()
        # 检查是否'init'或'gitc-init'命令
850     if cmd == 'init' or cmd == 'gitc-init':
          # 如果存在'.git'目录
851       if my_git:
            # 提取其路径和引用版本来更新REPO_URL和REPO_REV
852         _SetDefaultsTo(my_git)
853       try:
854         _Init(args, gitc_init=(cmd == 'gitc-init'))
855       except CloneFailure:
856         shutil.rmtree(os.path.join(repodir, S_repo), ignore_errors=True)
857         sys.exit(1)
858       repo_main, rel_repo_dir = _FindRepo()
        # 当前执行位置没有repo库，却又想执行repo命令的情况下，提示没有找到该命令，需要先安装repo库
859     else:
860       _NoCommands(cmd)
861 
862   if my_main:
863     repo_main = my_main
864 
865   ver_str = '.'.join(map(str, VERSION))
866   me = [sys.executable, repo_main,
867         '--repo-dir=%s' % rel_repo_dir,
868         '--wrapper-version=%s' % ver_str,
869         '--wrapper-path=%s' % wrapper_path,
870         '--']
871   me.extend(orig_args)
872   me.extend(extra_args)
873   try:
874     os.execv(sys.executable, me)
875   except OSError as e:
876     _print("fatal: unable to start %s" % repo_main, file=sys.stderr)
877     _print("fatal: %s" % e, file=sys.stderr)
878     sys.exit(148)
879 
880 
```
第825~880行：定义了main函数，通过调用其它的函数，实现了repo脚本的主要执行逻辑

```
    # repo脚本的主入口，以android官方的'init'命令为例：
    # 'repo init -u https://android.googlesource.com/platform/manifest -b android-4.0.1_r1'
881 if __name__ == '__main__':
      # 第148行获取了系统版本：ver = sys.version_info，如果运行的环境是Python3，打印提示消息
882   if ver[0] == 3:
883     _print('warning: Python 3 support is currently experimental. YMMV.\n'
884            'Please use Python 2.6 - 2.7 instead.',
885            file=sys.stderr)
      # 命令行解析参数时：
      # 如：'repo init -u https://android.googlesource.com/platform/manifest -b android-4.0.1_r1'
      # 则：argv = ['repo', 'init', '-u', 'https://android.googlesource.com/platform/manifest', '-b', 'android-4.0.1_r1']
      # 这里将'repo'外的其余参数传给main函数
886   main(sys.argv[1:])
第881~886行：repo脚本执行的入口，以
